---
title: "Genes and Geography in Europe"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preparing the dataset

First we'll set up the environment. We need the `tidyverse` packages, as well as the `vegan` package to perfrorm the procrustes analysis


```{r env}
library(tidyverse)
library(vegan)
```

<br />
Let's read in the data

```{r import}
pca <- read_tsv("datasets/novembre_2008_pca.tsv")
colors <- read_tsv("datasets/novembre_2008_colours.tsv", col_names = c("country", "color"))
```

<br />
The variable `pca` contains the results of the principal component analysis of 1,387 European individuals from Novembre et al 2008. Let's have a look at the first few lines of the dataset:

```{r data1, echo=FALSE}
knitr::kable(
  head(pca), booktabs = TRUE
)
```

<br />
The color palette used for the countries is stored as a table in the variable `colors`:

```{r data2, echo=FALSE}
knitr::kable(
  head(colors), booktabs = TRUE
)
```

## Rotating the PCA

In order to find the rotation for the PCA that aligns best with the geographic location of the samples, we will use the `procrustes()` function from the package `procrustes`. We first need to convert both the principal components and geographic locations of the samples into matrix format.

```{r procrustes1}
loc <- pca %>%
    select(longitude, latitude) %>%
    as.matrix()

pca1 <- pca %>%
    select(PC1, PC2) %>%
    as.matrix()
```
   
<br />
Now we carry out the procrustes analysis to find the optimal rotation

```{r procrustes2}
rot <- procrustes(loc, pca1)
```

<br />
We can examine the result by using base R `plot` function on the resulting object

```{r procrustes3}
plot(rot)
```

<br />
The rotated PC coordinates can be extracted from the `Yrot` element of the result object. Here we add two new columns for the rotated PCs to our `pca` object

```{r procrustes4}
pca <- pca %>%
    mutate(PC1_rot = rot$Yrot[,1], PC2_rot = rot$Yrot[,2])
```

## Recreating Figure 1 of Novembre et al 2008

With the rotated PCA results calculated, everything is in place for creating the figure. First we set up the color scale for the countries

```{r viz1}
colorscale <- colors$color
names(colorscale) <- colors$country
```

<br />
Next, we calculate the median PC values for each country

```{r viz2}
pca_summary <- pca %>%
    group_by(country, alabels) %>%
    summarise_at(c("PC1_rot", "PC2_rot"), median)
```

<br />
To add rotated axes lines, we take the coordinates of the four points at the end of the axis ranges, and rotate them into the new coordinate space using the `predict` function on the procrustes output object

```{r viz3}
lim_pc1 <- extendrange(pca$PC1)
lim_pc2 <- extendrange(pca$PC2)

axis <- rbind(c(lim_pc1[1], 0), c(lim_pc1[2], 0), c(0, lim_pc2[1]), c(0, lim_pc2[2]))
axis_rot <- predict(rot, axis, truemean = FALSE)
axis_rot_df  <- tibble(x = axis_rot[c(1, 3),1], xend = axis_rot[c(2, 4),1], y = axis_rot[c(1, 3),2], yend = axis_rot[c(2, 4), 2])
```

<br />
Similarly, we calculate rotated coordinates for two axis labels, in a position shifted towards the origin from the axis end point

```{r viz4}
labels <- rbind(c(lim_pc1[2] * 0.85, 0), c(0, lim_pc2[2] * 0.85))
labels_rot <- predict(rot, labels, truemean = FALSE) %>%
    as_tibble() %>%
    mutate(labels = c("PC1", "PC2"))
colnames(labels_rot)[1:2] <- c("PC1_rot", "PC2_rot")
```

<br />
Finally, we need to calculate the rotation angle from the rotation matrix for the axis label text

```{r viz5}
theta1 <- acos(rot$rotation[1,1]) * 180 / pi
```

<br />
With all objects in place we can now build the final plot

```{r viz6}
p <- ggplot(pca, aes(x = PC1_rot, y = PC2_rot))
p +
    geom_segment(aes(x = x, xend = xend, y = y, yend = yend), size = 0.25, arrow = arrow(ends = "both", angle = 10, type = "closed", length = unit(0.02, "npc")), data = axis_rot_df) +
    geom_point(size = 10, colour = "white", data = labels_rot) +
    geom_text(aes(label = labels), angle = c(theta1 + 180, theta1 + 270), data = labels_rot) +
    geom_text(aes(label = alabels, colour = country), alpha = 0.8, size = 2) +
    geom_point(aes(colour = country), size = 7, data = pca_summary) +
    geom_text(aes(label = alabels), size = 3, data = pca_summary) +
    scale_color_manual(name = "Country", values = colorscale) +
    coord_equal() +
    theme_void() +
    theme(legend.position = "none")
```


## Predicting location of origin from the PCA position

In this last section, we will follow the paper and build a predictor for an individual's geographic location from its PCA position, using linear regression. As test case, we take all individuals of a country of choice, remove them from the dataset and use the remaining individuals to build the model. Then, we use the built model to predict the location of the test individuals. 

<br />
First we split our dataset into training and test data
```{r pred1}
test_country <- "Germany"
d_train <- filter(pca, country != test_country)
d_test <- filter(pca, country == test_country)
```

<br />
Next, we carry out two linear regressions, modelling both longitude and latitude as functions of the rotated PCs and including their interaction term
```{r pred2}
lm_long <- lm(longitude ~ PC1_rot * PC2_rot, data = d_train)
lm_lat <- lm(latitude ~ PC1_rot * PC2_rot, data = d_train)
```

<br />
Now we use the `predict()` function to infer the predicted geographic location for the test samples, and reshape the results into a format useful for plotting 
```{r pred3}
d1 <- select(d_test, sampleId, longitude, latitude) %>%
    mutate(longitude_pr = predict(lm_long, d_test), latitude_pr = predict(lm_lat, d_test), longitude_orig = longitude, latitude_orig = latitude) %>%
    select(-longitude:-latitude) %>%
    pivot_longer(-sampleId) %>%
    separate(name, into = c("variable", "group")) %>%
    pivot_wider(names_from = variable, values_from = value)
```

<br />
Finally, we can plot the inferred versus actual sample locations using the basic map plotting functionality in `ggplot2`
```{r pred4}
w <- map_data("world")

lim_long <- extendrange(pca$longitude)
lim_lat <- extendrange(pca$latitude)

pal <- c("black", "red")
names(pal) <- c("orig", "pr")
sh <- c(16, 4)
names(sh) <- c("orig", "pr")

p <- ggplot(w)
p +
    geom_polygon(aes(long, lat, group = group), fill = "white", color = "grey", size = 0.25) +
    geom_point(aes(x = longitude, y = latitude, colour = group, shape = group), size = 2, data = d1) +
    scale_color_manual(values = pal) +
    scale_shape_manual(values = sh) +
    coord_quickmap(xlim = lim_long, ylim = lim_lat)
```

